///////////////////////////////////////////////////////////////////////////////
//
// 版权所有 (c) 2011 - 2012
//
// 原始文件名称     : ProcessFunction.cpp
// 工程名称         : AntinvaderDriver
// 创建时间         : 2011-03-20
//
//
// 描述             : 关于进程信息的功能实现
//
// 更新维护:
//  0000 [2011-03-20] 最初版本.
//
///////////////////////////////////////////////////////////////////////////////

#include "ProcessFunction.h"
#include "AntinvaderDriver.h"
#include "ConfidentialProcess.h"

#include <ntddk.h>

/*---------------------------------------------------------
函数名称:   InitProcessNameOffset
函数描述:   初始化EPROCESS结构中进程名的地址
输入参数:
输出参数:
返回值:
其他:       参考了楚狂人(谭文)的思路
更新维护:   2011.3.20    最初版本
---------------------------------------------------------*/
void InitProcessNameOffset()
{
    ULONG i;
    PEPROCESS peCurrentProcess;
    peGlobalProcessSystem = PsGetCurrentProcess();

    peCurrentProcess = peGlobalProcessSystem;

    //
    // 搜索 EPROCESS 结构,在其中找到 System 字符串地址,
    // 则该地址为 EPROCESS 中进程名称地址.
    //
    for (i = 0; i < MAX_EPROCESS_SIZE; i++) {
        if (!strncmp("System", (PCHAR)peCurrentProcess + i, strlen("System"))) {
            stGlobalProcessNameOffset = i;
            break;
        }
    }
}

/*---------------------------------------------------------
函数名称:   GetCurrentProcessName
函数描述:   初始化EPROCESS结构中进程名的地址
输入参数:   usCurrentProcessName    保存进程名的缓冲区
输出参数:   usCurrentProcessName    保存的进程名地址
返回值:     进程名长度
其他:       参考了楚狂人(谭文)的思路
更新维护:   2011.3.20    最初版本
---------------------------------------------------------*/
ULONG FltGetCurrentProcessNameA(
    __in PANSI_STRING ansiCurrentProcessName,
    __out PBOOLEAN pSucceed
    )
{
    PEPROCESS peCurrentProcess;
    ULONG ulLenth;

    //
    // 确保IRQL <= APC_LEVEL
    //
    PAGED_CODE();

    if (stGlobalProcessNameOffset == 0) {
        if (pSucceed)
            *pSucceed = FALSE;
        return 0;
    }

    //
    // 获得当前进程 EPROCESS, 然后移动一个偏移得到进程名所在位置.
    //
    peCurrentProcess = PsGetCurrentProcess();
    if (peCurrentProcess == NULL) {
        if (pSucceed)
            *pSucceed = FALSE;
        return 0;
    }

    //
    // 直接将这个字符串填到 ansiCurrentProcessName 里面.
    //
    RtlInitAnsiString(ansiCurrentProcessName,
                      ((PCHAR)peCurrentProcess + stGlobalProcessNameOffset));

    if (pSucceed)
        *pSucceed = TRUE;

    return ansiCurrentProcessName->Length;
}

/*---------------------------------------------------------
函数名称:   GetCurrentProcessName
函数描述:   初始化EPROCESS结构中进程名的地址
输入参数:   usCurrentProcessName    保存进程名的缓冲区
输出参数:   usCurrentProcessName    保存的进程名地址
返回值:     进程名长度
其他:       参考了楚狂人(谭文)的思路
更新维护:   2011.3.20    最初版本
---------------------------------------------------------*/
ULONG FltGetCurrentProcessName(
    __in PUNICODE_STRING usCurrentProcessName,
    __out PBOOLEAN pSucceed
    )
{
    PEPROCESS peCurrentProcess;
    ULONG i, ulLenth;
    ANSI_STRING ansiCurrentProcessName;

    //
    // 确保IRQL <= APC_LEVEL
    //
    PAGED_CODE();

    if (stGlobalProcessNameOffset == 0) {
        if (pSucceed)
            *pSucceed = FALSE;
        return 0;
    }

    //
    // 获得当前进程 EPROCESS, 然后移动一个偏移得到进程名所在位置.
    //
    peCurrentProcess = PsGetCurrentProcess();
    if (peCurrentProcess == NULL) {
        if (pSucceed)
            *pSucceed = FALSE;
        return 0;
    }

    //
    // 直接将这个字符串填到ansiCurrentProcessName里面.
    //
    RtlInitAnsiString(&ansiCurrentProcessName,
                      ((PCHAR)peCurrentProcess + stGlobalProcessNameOffset));

    //
    // 这个名字是ansi字符串, 现在转化为unicode字符串.
    //

    //
    // 获取需要的长度
    //
    ulLenth = RtlAnsiStringToUnicodeSize(&ansiCurrentProcessName);
    if (ulLenth > usCurrentProcessName->MaximumLength) {
        //
        // 如果长度不够则返回需要的长度, 并设置调用失败的标志.
        //
        if (pSucceed)
            *pSucceed = FALSE;
        return ulLenth;
    }

    //
    // 转换为Unicode
    //
    RtlAnsiStringToUnicodeString(usCurrentProcessName, &ansiCurrentProcessName, FALSE);
    //RtlFreeAnsiString(&ansiCurrentProcessName);

    if (pSucceed)
        *pSucceed = TRUE;
    return ulLenth;
}

/*---------------------------------------------------------
函数名称:   IsProcessConfidential
函数描述:   判断进程是否是机密进程
输入参数:
            usProcessName   进程名称
            usProcessPath   进程路径
            usProcessMd5    进程MD5校验值
输出参数:
返回值:     完全匹配为0,否则为以下值的或结果

            PROCESS_NAME_NOT_CONFIDENTIAL   名称不匹配
            PROCESS_PATH_NOT_CONFIDENTIAL   路径不匹配
            PROCESS_MD5_NOT_CONFIDENTIAL    MD5校验不匹配

其他:       不需要检查的信息直接填为NULL即可

更新维护:   2011.4.5     最初版本  仅测试notepad.exe
            2011.7.25    接入Pct模块
---------------------------------------------------------*/

/*
ULONG IsProcessConfidential(
    PUNICODE_STRING usProcessName,
    PUNICODE_STRING usProcessPath,
    PUNICODE_STRING usProcessMd5
    )
{
    // 返回值, 记录不匹配信息
    ULONG ulRet;

    // 传入数据
    CONFIDENTIAL_PROCESS_DATA cpdProcessData;

    if (!)

    UNICODE_STRING usProcessConfidential = { 0 };
    if (usProcessName) {
        RtlInitUnicodeString(&usProcessConfidential, L"notepad.exe");
        if (RtlCompareUnicodeString(usProcessName, &usProcessConfidential, TRUE) == 0)
            return 0;
        return PROCESS_NAME_NOT_CONFIDENTIAL;
    }

    return 0;
}
*/

/*---------------------------------------------------------
函数名称:   IsCurrentProcessSystem
函数描述:   判断当前进程是否是机密进程
输入参数:
输出参数:
返回值:     当前进程是否是System
其他:       测试对WPS加密时发现有时会有System的线程对机密
            文件进行操作.故如果是机密文件且是System进程
            同意加密.
更新维护:   2011.7.27    最初版本
---------------------------------------------------------*/
inline BOOLEAN IsCurrentProcessSystem() {
    return (peGlobalProcessSystem == PsGetCurrentProcess());
}

/*---------------------------------------------------------
函数名称:   IsCurrentProcessConfidential
函数描述:   判断当前进程是否是机密进程
输入参数:
输出参数:
返回值:     当前进程是否是机密进程
其他:
更新维护:   2011.4.3     最初版本 仅测试notepad
            2011.7.25    接入机密进程表模块 仅测试
---------------------------------------------------------*/

BOOLEAN IsCurrentProcessConfidential()
{
    WCHAR wProcessNameBuffer[64] = { 0 };
    CONFIDENTIAL_PROCESS_DATA cpdCurrentProcessData = { 0 };
    UNICODE_STRING usProcessConfidential = { 0 };
    UNICODE_STRING usProcessName = { 0 };
    UNICODE_STRING usLowerProcessName = { 0 };
    ULONG ulLength;
    BOOLEAN bSucceed = FALSE;
    BOOLEAN isConfidentialProcess;

    RtlInitEmptyUnicodeString(
        &cpdCurrentProcessData.usName,
        wProcessNameBuffer,
        64 * sizeof(WCHAR));

    ulLength = FltGetCurrentProcessName(&cpdCurrentProcessData.usName, &bSucceed);
    if (!bSucceed) {
        KdDebugPrint("[Antinvader] IsCurrentProcessConfidential(): call GetCurrentProcessName() failed."
            " ulLength = %u\n", ulLength);
        return FALSE;
    }
    KdDebugPrint("[Antinvader] IsCurrentProcessConfidential() ProcessName: %ws, ulLength = %u\n",
        cpdCurrentProcessData.usName.Buffer, ulLength);

#if 0
    __try {
        return PctGetSpecifiedProcessDataAddress(&cpdCurrentProcessData, NULL);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        FLT_ASSERT(FALSE);
    }
#endif

    RtlInitUnicodeString(&usProcessConfidential, L"notepad.exe");
    RtlInitUnicodeString(&usProcessName, cpdCurrentProcessData.usName.Buffer);
    RtlDowncaseUnicodeString(&usLowerProcessName, &usProcessName, TRUE);

    if (RtlCompareUnicodeString(&usLowerProcessName, &usProcessConfidential, TRUE) == 0)
        isConfidentialProcess = TRUE;
    else
        isConfidentialProcess = FALSE;

    RtlFreeUnicodeString(&usLowerProcessName);

    return isConfidentialProcess;
}

/*---------------------------------------------------------
函数名称:   GetCurrentProcessPath
函数描述:   获取当前进程路径信息

输入参数:   puniFilePath    指向有效内存的字符串指针

输出参数:   puniFilePath    包含镜像所在路径的字符串

返回值:     TRUE, 如果成功找到.
            FALSE, 失败.

其他:       不必初始化传入时的Buffer地址

            原理就是去进程的PEB中把数据刨出来

            一定注意这个函数会申请内存用于存放路径
            记得用完了释放

更新维护:   2011.4.3     最初版本
---------------------------------------------------------*/
BOOLEAN GetCurrentProcessPath(__inout PUNICODE_STRING puniFilePath)
{
    // PEB结构地址
    ULONG ulPeb;

    // Parameter结构地址
    ULONG ulParameters;

    // 当前进程
    PEPROCESS  peCurrentProcess;

    // 找到的地址,等待拷贝
    PUNICODE_STRING puniFilePathLocated;

    //
    // 获得当前进程EPROCESS
    //
    peCurrentProcess = PsGetCurrentProcess();

    //
    // 对不确定的内存进行访问,经常出错,结构化异常处理套上
    //
    __try {
        //
        // 获取当前进程PEB地址
        //
        ulPeb = *(ULONG*)((ULONG)peCurrentProcess + PEB_STRUCTURE_OFFSET);

        //
        // 空指针说明是内核进程, 肯定没有PEB结构.
        //
        if (!ulPeb) {
            return FALSE;
        }

        //
        // 检测地址是否有效, 无效肯定也不行.
        //
        if (!MmIsAddressValid((PVOID)ulPeb)) {
            return (BOOLEAN)(-1);
        }

        //
        // 计算Parameter地址, 由于不存在指针而
        // 直接是将结构体本身放在了这里, 故不需
        // 要再次进行地址有效性检测.
        //
        ulParameters = *(PULONG)((ULONG)ulPeb+PARAMETERS_STRUCTURE_OFFSET);

        //
        // 计算Path地址
        //
        puniFilePathLocated = (PUNICODE_STRING)(ulParameters+IMAGE_PATH_STRUCTURE_OFFSET);

        //
        // 申请内存
        //
        puniFilePath->Buffer = (PWCH)ExAllocatePoolWithTag(
            NonPagedPool,
            puniFilePathLocated->MaximumLength + 2,
            MEM_PROCESS_FUNCTION_TAG);

        //
        // 拷贝数据
        //
        RtlCopyUnicodeString(puniFilePath, puniFilePathLocated);

        return TRUE;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        KdDebugPrint("[Antinvader] Severe error occured when getting current process path.\r\n");
#if defined(DBG) && !defined(_WIN64)
        __asm int 3
#endif
    }

    return FALSE;
}
